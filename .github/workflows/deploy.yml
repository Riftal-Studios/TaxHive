name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      deploy_type:
        description: 'Deployment type'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - rebuild
          - migrate-only

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile.production
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDTIME=${{ github.event.head_commit.timestamp }}
            VERSION=${{ github.sha }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: https://gsthive.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment package
        run: |
          mkdir -p deployment
          cp docker/docker-compose.production.yml deployment/docker-compose.yml
          cp scripts/deploy/deploy.sh deployment/
          
          # Create .env file from secrets
          cat > deployment/.env.production << EOF
          # Database
          POSTGRES_USER=${{ vars.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ vars.POSTGRES_DB }}
          
          # Redis
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          
          # NextAuth
          NEXTAUTH_URL=${{ vars.NEXTAUTH_URL }}
          NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
          
          # Email Configuration - Amazon SES
          EMAIL_PROVIDER=${{ vars.EMAIL_PROVIDER }}
          EMAIL_SERVER=${{ secrets.EMAIL_SERVER }}
          EMAIL_FROM=${{ vars.EMAIL_FROM }}
          AWS_SES_ACCESS_KEY_ID=${{ secrets.AWS_SES_ACCESS_KEY_ID }}
          AWS_SES_SECRET_ACCESS_KEY=${{ secrets.AWS_SES_SECRET_ACCESS_KEY }}
          AWS_SES_REGION=${{ vars.AWS_SES_REGION }}
          
          # AWS S3 (Optional)
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ vars.AWS_REGION }}
          AWS_S3_BUCKET=${{ vars.AWS_S3_BUCKET }}
          
          # API Keys
          RBI_API_KEY=${{ secrets.RBI_API_KEY }}
          EXCHANGE_RATE_API_KEY=${{ secrets.EXCHANGE_RATE_API_KEY }}
          
          # Cron Secret
          CRON_SECRET=${{ secrets.CRON_SECRET }}
          
          # Cloudflare Tunnel
          CLOUDFLARE_TUNNEL_TOKEN=${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
          
          # Docker Registry
          DOCKER_REGISTRY=${{ env.REGISTRY }}
          DOCKER_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          EOF
          
          # Update docker-compose to use registry image
          sed -i 's|build:|image: ${DOCKER_IMAGE}\n    # build:|g' deployment/docker-compose.yml
          
          # Create deployment script
          cat > deployment/remote-deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Colors
          GREEN='\033[0;32m'
          RED='\033[0;31m'
          NC='\033[0m'
          
          echo -e "${GREEN}Starting deployment...${NC}"
          
          # Login to GitHub Container Registry
          echo $GITHUB_TOKEN | docker login ghcr.io -u $GITHUB_USER --password-stdin
          
          # Pull latest images
          docker-compose pull
          
          # Deploy based on type
          case "$DEPLOY_TYPE" in
            "rebuild")
              echo -e "${GREEN}Rebuilding all services...${NC}"
              docker-compose down
              docker-compose up -d --force-recreate
              ;;
            "migrate-only")
              echo -e "${GREEN}Running migrations only...${NC}"
              docker-compose run --rm app npx prisma migrate deploy
              ;;
            *)
              echo -e "${GREEN}Standard deployment...${NC}"
              docker-compose up -d
              sleep 10
              docker-compose exec -T app npx prisma migrate deploy
              ;;
          esac
          
          # Health check
          sleep 5
          docker-compose exec -T app wget -qO- http://localhost:3000/api/health || exit 1
          
          # Cleanup old images
          docker image prune -f
          
          echo -e "${GREEN}Deployment completed successfully!${NC}"
          EOF
          
          chmod +x deployment/remote-deploy.sh
          tar -czf deployment.tar.gz deployment/

      - name: Copy deployment package to VPS
        uses: appleboy/scp-action@v1.0.0
        with:
          host: ${{ vars.VPS_HOST }}
          username: ${{ vars.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ vars.VPS_PORT }}
          source: deployment.tar.gz
          target: /tmp/

      - name: Deploy to VPS
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ vars.VPS_HOST }}
          username: ${{ vars.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ vars.VPS_PORT }}
          script: |
            # Extract deployment package to production directory
            mkdir -p /home/${{ vars.VPS_USER }}/gsthive-production
            cd /home/${{ vars.VPS_USER }}/gsthive-production
            
            # Clean up old deployment files
            rm -rf deployment
            
            # Extract new deployment
            tar -xzf /tmp/deployment.tar.gz
            mv deployment/* .
            rmdir deployment
            
            # Set environment variables for deployment
            export GITHUB_TOKEN='${{ secrets.GITHUB_TOKEN }}'
            export GITHUB_USER='${{ github.actor }}'
            export DEPLOY_TYPE='${{ github.event.inputs.deploy_type || 'deploy' }}'
            export COMPOSE_PROJECT_NAME='gsthive-prod'
            
            # Run deployment
            ./remote-deploy.sh
            
            # Cleanup
            rm -f /tmp/deployment.tar.gz

      - name: Notify deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}';
            const emoji = status === 'success' ? '✅' : '❌';
            const message = `${emoji} Deployment to production ${status}`;
            
            // Create deployment status
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 1,
              state: status === 'success' ? 'success' : 'failure',
              environment: 'production',
              description: message
            });

  cleanup:
    needs: deploy
    runs-on: ubuntu-latest
    if: success()
    
    steps:
      - name: Clean up VPS
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ vars.VPS_HOST }}
          username: ${{ vars.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ vars.VPS_PORT }}
          script: |
            # Remove deployment files
            rm -rf /home/${{ vars.VPS_USER }}/deployment
            
            # Clean up Docker
            docker system prune -f
            docker volume prune -f
            
            # Keep only last 3 images
            docker images | grep ghcr.io | tail -n +4 | awk '{print $3}' | xargs -r docker rmi